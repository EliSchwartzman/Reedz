import os  # Environment variable access
from datetime import datetime, timedelta, timezone
from dotenv import load_dotenv      # Load .env configuration file
from supabase import create_client, Client  # Official Supabase Python client
from models import User, Bet, Prediction  # Data models for type safety
import time  # For sleep during reset operation


# Load environment configuration
load_dotenv()

# Supabase connection credentials (required)
SUPABASE_URL = os.getenv("SUPABASE_URL")
SUPABASE_KEY = os.getenv("SUPABASE_KEY")

# Validate required environment variables
if not SUPABASE_URL or not SUPABASE_KEY:
    raise Exception("SUPABASE_URL and SUPABASE_KEY must be set in your .env file.")

# Initialize Supabase client connection
supabase: Client = create_client(SUPABASE_URL, SUPABASE_KEY)

# USER OPERATIONS

def create_user(user: User):
    """
    Creates new user account in 'users' table.
    
    Args:
        user (User): User model instance with all required fields
    
    Returns:
        Supabase response object
    """
    # Insert user data (user_id auto-generated by database)
    res = supabase.table("users").insert({
        "username": user.username,
        "password": user.password,  # bcrypt hash
        "email": user.email,
        "reedz_balance": user.reedz_balance,
        "role": user.role,
        "created_at": (user.created_at.isoformat() 
                      if isinstance(user.created_at, datetime) 
                      else user.created_at),
    }).execute()
    return res


def list_all_users():
    """Retrieves all users with essential fields for admin dashboard."""
    res = supabase.table("users").select(
        "user_id, username, email, role, reedz_balance"
    ).execute()
    return res.data  # List of user dictionaries


def get_user_by_username(username):
    """Fetches single user by unique username, returns User model."""
    res = supabase.table("users").select("*").eq("username", username).limit(1).execute()
    data = res.data
    if not data:
        return None
    
    user = data[0]
    return User(
        user_id=user["user_id"],
        username=user["username"],
        password=user["password"],
        email=user["email"],
        reedz_balance=user["reedz_balance"],
        role=user["role"],
        created_at=user["created_at"]
    )


def get_user_by_email(email):
    """Fetches single user by email address, returns User model."""
    res = supabase.table("users").select("*").eq("email", email).limit(1).execute()
    data = res.data
    if not data:
        return None
    
    user = data[0]
    return User(
        user_id=user["user_id"],
        username=user["username"],
        password=user["password"],
        email=user["email"],
        reedz_balance=user["reedz_balance"],
        role=user["role"],
        created_at=user["created_at"]
    )


def get_user_by_id(user_id):
    """Fetches single user by primary key, returns User model."""
    res = supabase.table("users").select("*").eq("user_id", user_id).execute()
    data = res.data
    if not data:
        return None
    
    user_data = data[0]
    return User(
        user_id=user_data["user_id"],
        username=user_data["username"],
        password=user_data["password"],
        email=user_data["email"],
        reedz_balance=user_data["reedz_balance"],
        role=user_data["role"],
        created_at=user_data["created_at"],
    )


def update_user_password(user_id, hashed_password):
    """Updates user password hash by user_id."""
    res = supabase.table("users").update({"password": hashed_password}).eq("user_id", user_id).execute()
    return res


def update_user_password_by_email(email, hashed_password):
    """Updates user password hash by email address."""
    res = supabase.table("users").update({"password": hashed_password}).eq("email", email).execute()
    return res


def update_user_email(user_id, new_email):
    """Updates user email address."""
    res = supabase.table("users").update({"email": new_email}).eq("user_id", user_id).execute()
    return res


def set_user_reset_code(email, code, expiry):
    """
    Stores temporary password reset code with 5-minute expiry.
    
    Args:
        email (str): Target user email
        code (str): 6-digit numeric reset code
        expiry (datetime): UTC expiration timestamp
    """
    res = supabase.table("users").update({
        "reset_code": code,
        "reset_code_expiry": (expiry.isoformat() 
                            if isinstance(expiry, datetime) 
                            else expiry)
    }).eq("email", email).execute()
    return res


def check_reset_code(email, code):
    """
    Validates password reset code against stored value and expiry.
    
    Args:
        email (str): User email
        code (str): 6-digit code from email
    
    Returns:
        bool: True if valid and not expired
    """
    res = supabase.table("users").select("reset_code, reset_code_expiry").eq("email", email).execute()
    if not res.data:
        return False
    
    user = res.data[0]
    stored_code = user.get("reset_code")
    expiry = user.get("reset_code_expiry")
    
    # Invalid code or missing expiry
    if not stored_code or not expiry or stored_code != code:
        return False
    
    try:
        # Parse expiry with UTC timezone handling
        expiry_dt = datetime.fromisoformat(expiry)
        if expiry_dt.tzinfo is None:
            expiry_dt = expiry_dt.replace(tzinfo=timezone.utc)
    except Exception:
        # Clear invalid expiry data
        supabase.table("users").update({
            "reset_code": None, 
            "reset_code_expiry": None
        }).eq("email", email).execute()
        return False

    # Check if expired (extra 5min buffer for clock drift)
    now_utc = datetime.now(timezone.utc)
    if expiry_dt < now_utc - timedelta(minutes=5):
        supabase.table("users").update({
            "reset_code": None, 
            "reset_code_expiry": None
        }).eq("email", email).execute()
        return False
    
    return True  # Valid and active


def clear_reset_code(email):
    """Clears used/expired reset code from user record."""
    res = supabase.table("users").update({
        "reset_code": None, 
        "reset_code_expiry": None
    }).eq("email", email).execute()
    return res


def add_reedz(user_id, delta):
    """
    Incrementally adjusts user Reedz balance (positive or negative).
    
    Args:
        user_id (int): Target user
        delta (int): Amount to add/subtract
    """
    user = get_user_by_id(user_id)
    if not user:
        return None
    
    new_balance = user.reedz_balance + delta
    res = supabase.table("users").update({
        "reedz_balance": new_balance
    }).eq("user_id", user_id).execute()
    return res


def delete_user(user_id):
    """Permanently deletes user account and related data."""
    res = supabase.table("users").delete().eq("user_id", user_id).execute()
    return res


def change_role(user_id, new_role):
    """Updates user role (Admin/Member)."""
    res = supabase.table("users").update({"role": new_role}).eq("user_id", user_id).execute()
    return res


def get_leaderboard():
    """Returns users sorted by Reedz balance (descending)."""
    res = supabase.table("users").select("username, reedz_balance").order(
        "reedz_balance", desc=True
    ).execute()
    return res.data

def change_role(user_id, new_role):
    """Updates user role (Admin/Member)."""
    return supabase.table("users").update({"role": new_role}).eq("user_id", user_id).execute()

# BET OPERATIONS

def create_bet(bet: Bet):
    """
    Creates new betting market in 'bets' table.
    
    Args:
        bet (Bet): Bet model with all market details
    """
    res = supabase.table("bets").insert({
        "created_by_user_id": bet.created_by_user_id,
        "title": bet.title,
        "description": bet.description,
        "answer_type": bet.answer_type,
        "is_open": bet.is_open,
        "is_resolved": bet.is_resolved,
        "is_closed": bet.is_closed,
        "created_at": (bet.created_at.isoformat() 
                      if isinstance(bet.created_at, datetime) 
                      else bet.created_at),
        "close_at": (bet.close_at.isoformat() 
                    if isinstance(bet.close_at, datetime) 
                    else bet.close_at),
        "resolved_at": (bet.resolved_at.isoformat() 
                       if bet.resolved_at and isinstance(bet.resolved_at, datetime) 
                       else bet.resolved_at),
        "correct_answer": bet.correct_answer,
    }).execute()
    return res


def get_bet(bet_id):
    """Fetches single bet by ID, returns Bet model."""
    res = supabase.table("bets").select("*").eq("bet_id", bet_id).execute()
    data = res.data
    if data:
        b = data[0]
        return Bet(
            bet_id=b["bet_id"],
            created_by_user_id=b["created_by_user_id"],
            title=b["title"],
            description=b["description"],
            answer_type=b["answer_type"],
            is_open=b["is_open"],
            is_resolved=b["is_resolved"],
            is_closed=b.get("is_closed", False),
            created_at=b["created_at"],
            close_at=b["close_at"],
            resolved_at=b["resolved_at"],
            correct_answer=b["correct_answer"],
        )
    return None


def get_bets_by_state(state):
    """
    Filters bets by lifecycle state.
    
    Args:
        state (str): "open", "closed", "resolved", or "" (all)
    
    Returns:
        List of bet dictionaries
    """
    # Base query with essential fields
    """Filters bets by lifecycle state: open, closed, resolved, or all."""
    # Auto-close any bets whose close_at is in the past but are still open
    auto_close_expired_bets()

    bets = supabase.table("bets").select(
        "bet_id, created_by_user_id, title, description, answer_type, "
        "correct_answer, is_open, is_resolved, is_closed, created_at, "
        "close_at, resolved_at"
    )

    if state == "open":
        # Open = not closed and not resolved
        res = (
            bets
            .eq("is_closed", False)
            .eq("is_resolved", False)
            .execute()
        )
    elif state == "closed":
        # Closed (but not yet resolved)
        res = (
            bets
            .eq("is_closed", True)
            .eq("is_resolved", False)
            .execute()
        )
    elif state == "resolved":
        # Resolved = final state
        res = bets.eq("is_resolved", True).execute()
    else:
        # All bets, no state filter
        res = bets.execute()

    return res.data

def get_bet_overview(state):
    """Alias for get_bets_by_state() - used by UI."""
    return get_bets_by_state(state)


def close_bet(bet_id):
    """Close bet: stop predictions, mark as closed but unresolved."""
    res = (supabase.table('bets')
           .update({'is_open': False, 'is_closed': True})
           .eq('bet_id', bet_id)
           .eq('is_resolved', False)  # Only close unresolved bets
           .execute())
    return res

def auto_close_expired_bets():
    """Automatically close any bets whose close_at is in the past."""
    now_utc = datetime.now(timezone.utc)

    res = (
        supabase.table("bets")
        .select("bet_id, close_at, is_closed, is_resolved")
        .eq("is_closed", False)
        .eq("is_resolved", False)
        .execute()
    )

    for b in res.data or []:
        close_at = b.get("close_at")
        if not close_at:
            continue

        try:
            close_dt = datetime.fromisoformat(close_at)
        except Exception:
            continue

        if close_dt.tzinfo is None:
            close_dt = close_dt.replace(tzinfo=timezone.utc)

        if close_dt <= now_utc:
            close_bet(b["bet_id"])


def resolve_bet(bet_id, correct_answer):
    """Resolve bet: set answer + mark fully resolved."""
    res = (supabase.table('bets')
           .update({
               'is_open': False,           # No more predictions
               'is_closed': True,          # Closed state  
               'is_resolved': True,        # Final state
               'correct_answer': correct_answer,
               'resolved_at': 'now()'      # Timestamp
           })
           .eq('bet_id', bet_id)
           .execute())
    return res

# PREDICTION OPERATIONS

def create_prediction(prediction: Prediction):
    """Records user's prediction on a bet."""
    res = supabase.table("predictions").insert({
        "user_id": prediction.user_id,
        "bet_id": prediction.bet_id,
        "prediction": prediction.prediction,
        "created_at": (prediction.created_at.isoformat() 
                      if isinstance(prediction.created_at, datetime) 
                      else prediction.created_at),
    }).execute()
    return res


def get_predictions_for_bet(bet_id):
    """Returns all predictions for specific bet as Prediction objects."""
    res = supabase.table("predictions").select("*").eq("bet_id", bet_id).execute()
    data = res.data
    preds = []
    for p in data:
        preds.append(Prediction(
            prediction_id=p["prediction_id"],
            user_id=p["user_id"],
            bet_id=p["bet_id"],
            prediction=p["prediction"],
            created_at=p["created_at"]
        ))
    return preds


def get_user_predictions(user_id):
    """Returns all predictions made by specific user."""
    res = supabase.table("predictions").select("*").eq("user_id", user_id).execute()
    return res.data  # Raw dictionaries


def has_prediction(user_id, bet_id):
    """Checks if user already predicted on specific bet (one-per-user rule)."""
    res = supabase.table("predictions").select("prediction_id").eq(
        "user_id", user_id
    ).eq("bet_id", bet_id).limit(1).execute()
    return bool(res.data)  # True if prediction exists


# Reset Function
def reset_database():
    """Admin utility to wipe bets, predictions, and reset user balances."""
    supabase.table("predictions").delete().neq("prediction_id", 0).execute()
    supabase.table("bets").delete().neq("bet_id", 0).execute()
    supabase.table("users").update({"reedz_balance": 0}).neq("user_id", 0).execute()
    time.sleep(1)
    return True

